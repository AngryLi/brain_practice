# 第二章 内存管理

内存管理绝对是iOS面试时的一大考点。内存管理、多线程、block，看成iOS必考三大模块，都是上手容易，深究难。

## 2.1 内存消耗

- 关注应用的内存消耗会给用户带来更好的体验

### 2.1.1 栈大小

栈的大小决定了以下的限制：

1. 可递归的最大方法树。
2. 一个方法中最多可使用的变量个数。
3. 视图层集中可以嵌入的最大视图深度。

__在iOS中，每个线程都有自己独立的栈空间__

### 2.1.2 堆大小

**应用不能操作分配各它的堆，只有操作系统才能管理堆**

- 图片和json/xml文件会消耗大量的内存
- 堆的使用决定了应用使用中的最大内存消耗

## 2.2 内存管理模型

iOS中使用引用计数作为垃圾回收算法。引用计数是编程语言中常见的一种垃圾回收算法，并非iOS特有。

**就目前来讲，还有另外的两种回收算法：标记清除、复制收集。其他的算法都是通过组合使用这三种基本算法所得到的优化算法**(详情参照：《代码未来》2.4节 P61)

## 2.3 自动释放对象

MRC已经是过时的老古董了，可以不关注。只要知道在适当的地方使用autoreleasepool即可。

## 2.4 自动释放池

**关注这节主要关注下RunLoop和自动释放池的关系。这是一个面试的重点。**

主线程的RunLoop有一个自动释放池，所以那些看起来并没有主动当如autoreleasepool的releasing对象，就是被注入了这个pool。每当RunLoop休眠的时候都会释放这个池子中对象。

在内存使用比较集中的地方，继续依赖每次主线程RunLoop的释放，会造成内存消耗的峰值上升。所以在内存使用比较集中的地方，恰当的使用autoreleasepool和autorelease。典型的场景就是在for循环中创建临时变量(对象)。这也是面试会问到的，面试者也可以回答，但是深究的话很多人都不会的考点，只要深究，就涉及到RunLoop和autoreleasepool的关系。所以说这是多么的重要。

## 2.5 自动引用计数

在早期的iOS开发过程中，开发者都是手动管理对象的引用和释放(这和C、C++的内存申请和free不同)，所以至今还能看到那些使用MRC的开发者以使用过MRC为荣，即使他们开发出的程序漏洞百出。所以MRC也是面试时的一大考点。

让开发者手动管理对象应用，显然大多数开发者都不具备优良的开发能力，于是在Xcode5中，引入了ARC(automatic reference counting)，让编译器帮助开发者管理对象引用。

可以在程序中手动关闭ARC。

ARC和MRC在代码上会有一些差异。以前引用管理的方法几乎都不可用了(而是强制不需要开发编写了)。

对于MRC这个老古董，“如果你不知道他们的区别，那你就不用知道了”。面试的时候如果面试官问起，你大可以说“我开始iOS开发的时候已经普遍使用ARC”，一个理智的面试官都不会责备你。

## 2.6 应用类型

请合理使用 weak、strong、copy、assign，没有特殊需求请不要使用unsafe_unretained。

## 2.7 实践环节

深入到代码中去吧，那才是最好的实践。只要写出的代码不因为内存管理crash，就是好代码，比什么理论都好。

## 2.8 僵尸对象

开启僵尸对象可以帮助调试：

- 对已销毁对象的访问
- 多次释放的对象(ARC中貌似不会有这个问题了)

开启僵尸之后延迟了本该被释放的内存(请注意内存回收和对象回收的区别)，默认情况下不会有对象被真正的析构，将导致大量的内存消耗。__在release包中绝对不能开启__。

## 2.9 内存管理规则

请严格遵守iOS命名规则和属性限定符使用书册。

## 2.10 循环引用

循环引用是iOS开发中，比较常见的一个问题。由于iOS采用引用计数的垃圾回收算法，如果出现循环应用，又不能解开这个循环，环内的对象在应用程序运行期间都不能被释放。

### 2.10.1 避免循环引用的规则

- 如果持有父对象，使用weak
- 层级体系中，子对象应该保留祖先对象(请区分是层级关系)
- 使用专用的销毁方法中断循环引用。NSTimer对象应该使用invalidate方法首先销毁运行循环对NSTimer对象的引用，再释放。(这主要是因为NSTimer对象持有了self)

### 2.10.2 循环引用的常见场景

1. 委托

也就是常用protocol和delegate代理模式。问题的根源其实是子对象强引用了父对象。遵循上面的开发原则就不会出现这种情况。

有时候delegate的回调方法中导致循环引用，并不是delegate直接导致的，而是类型的不良代码导致的。比如在回调方法中使用了不恰当的block。排查原因是一定要注意区分之前的区别。

2. 块

block。

请使用`__weak typeof(self) weakSelf = self;`、` __strong typeof(self) self = weakSelf;`。

3. 线程和计时器

对象持有了计时器，计时器同时也持有了对象(问题就是计时器也持有了对象)，所以要在恰当时候断开其中一个引用，常见的做法是断开 self -> timer 的引用 `self.timer = nil;`。

计时器开始执行之后，不仅原有对象持有计时器，运行循环也会持有计时器。。。，如果只是断开self.timer的引用，将会导致timer对象无法释放。。。

所以销毁NSTimer对象，应该首先调用invalidate方法，断开运行循环对计时器的引用。

这里有一个计时器的最佳实践，耦合度低，可以用到具体的项目中。

### 2.10.3 观察者

注册观察者的方法不会维持观察对象、被观察对象及上下文对象的强引用。如有必要，需要自行维护对他们的强引用。所以这里讲的重点不是怎么避免循环引用的问题，而是在恰当地方移除观察者。

这里有一个最佳实践。其实不是最佳，有很多问题：

1. 如果被观察者不是 self.nameTextField 而正是 self，那就构成了 self -> resultLabelMonitor, resultLabelMonitor -> self 这个循环了。
2. 如果为了解决1的问题而target使用了weak，那self可以被销毁。那么问题来了，首先销毁self，然后resultLabelMonitor引用计数降为0，将被回收，执行dealloc方法，调用removeObserver移除观察者注册，而此时target的值已经是nil，众所周知在oc中对nil执行method不会有任何操作。那么也就不能执行移除观察者的操作。随后，观察者observer随着resultLabelMonitor的销毁，引用计数降为0，被回收。那么问题就变成了：观察者和被观察者都被回收了，但是观察者的注册还在，会不会有问题？

### 2.10.4 返回错误

__autoreleasing的使用。

## 2.11 若对象：id

避免直接使用 id 作为对象类型。

如果不适用id对象，也就不会用到下面的最佳实践。

## 2.12 对象寿命和泄露

对象存在时间越长，内存不被清理的可能性就越大，应当避免创建长寿命的对象。但对于关键操作对象，为了不每次都浪费时间创建他们，可以在使用这些对象时完成对他们的引用。

合理使用单例模式。

谨慎使用全局变量？？？

## 2.13 单例

最佳实践：

1. 尽可能避免使用单例
2. 识别需要使用内存的部分，必要时可使用磁盘缓存
3. 尽量减少对象级的属性，他们会和父对象共存亡，多使用自动变量。
  
  这里是有问题的：每次用到的时候都创建自动变量吗，浪费时间呀而且你不怕栈溢出吗；而且不只是对象级的属性少使用，所有属性都不该滥用，能使用自动变量不要是使用属性。

扩展：依赖注入。就是把你要在对象中使用的对象透传进去，而不是每次使用都去创建相同的对象，这样浪费时间和内存。

这里提到了：Typhoon和Objection。

## 2.14 找到神秘的持有者

请关注“引用图”。

## 2.15 最佳实践

- 避免使用单例，特别是上帝类
- 子对象使用strong引用
- 父对象使用weak引用
- 对 使引用图闭合的 对象使用weak
- 计数数据类型使用assign，特别注意SEL类型也是基础数据类型
- block常使用copy
- __autoreleasing
- 避免block直接引用外部变量
- block引用外部变量记得weak和strong处理
- 使用指定的回收方法释放对象引用

## 2.16 生产环境的内存使用情况

一段可以在debug和release环境下查询内存使用情况的代码。可以用于日志收集，不然你要他干嘛。
