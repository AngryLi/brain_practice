# 第6章
Erlang的虚拟机是唯一能和Java虚拟机相匹敌的对手(装逼，没图说个屁)。

Erlang十分注重效率，很少考虑除此之外的其他东西，因此语法方面并不像Ruby、Python等那样优雅和简洁(简直是在为语法垃圾找借口)。

## 6.1
Erlang全称是Ericsson Language。是由丹麦数学家Joe Armstrong在1986年于爱立信公司发明。一直处于不温不火的状态，反而到了2000年之后，这门语言慢慢被开发者重视起来。这其中和他的高并发性有分不开的关系。

## 6.1.1
Erlang具有多种优化并发的策略。
- 无线程：这条说的有的有点过了，并且有点多余，轻量级线程那也是线程呀。要是加上引号我就认了，可惜作者没加。
- 轻量级线程：为了避免多线程之间共享资源而必须使用进程锁带来的开销，Erlang使用轻量级线程（呵呵，我是没明白到底好在哪里，或许只是因为太小了，所以在第三条的时候说“就让他崩溃”，真任性）。
- 可靠性：Erlang为了处理大量并发带来的大量错误信息，采用“就让他崩溃”的策略，就因为他很容易检测到一个线程的崩溃并且能很容易的创建一个新线程，所以，我没看出可靠性在哪里，明明就是破罐子破摔。

以上三种特性(其实是两种才是吧)加起来，还真让人觉得有可能他还真能做成点什么，你非要说这些构成了强大的并发特性，我也是呵呵了。

另外，Erlang能够做到在程序不停止运行的状态下插入新代码，这个真厉害，这就能保证程序运行几年甚至几十年都不人为泵机。也就少了凌晨四点开发人员等待用户最少的那一刻停止服务器上传新代码的窘境了。

## 6.1.2
Joe Armstrong博士访谈录，谁生的孩子谁喜欢，我看松本行弘也很喜欢他自己的Ruby，然而在开发者使用量和近两年的走势来看，如果没有Rails，谁知道Ruby是个啥，也就是个三流语言，然而现在也就是个二流语言，Erlang也一样仰仗着他的高并发。

访谈中还妄想加入Prolog的声明型编程模式，加呀，我开心的受不了。

## 6.2
命令行模式下， c 命令中填充的是 file name，而非 module name。

Erlang中，module的name必须和所在file的name保持一致，否则会报错 `y.beam: Module name 'y1' does not match file name 'y'`，其中 y1 是module name，y 是 file name。

## 6.3
列表的操作函数 foldl 就行python中的reduce函数一样。看的出来，这些内建的高阶函数无非也就是这么几种。

### 6.3.4 列表的一些高级概念
#### 1. 列表构造

**问题**

我发现一个很奇怪的现象：
正确代码：
```
-module(y).
-export([doubleAll/1]).

doubleAll([]) -> [];
doubleAll([Head|Tail]) -> [Head|[Head|doubleAll(Tail)]].

// 命令行
c(y).
y:doubleAll([1, 2, 3]).
// 输出
[1,1,2,2,3,3] // 正确结果
```

错误代码：
```
-module(y).
-export([doubleAll/1]).

doubleAll([]) -> [];
doubleAll([Head|Tail]) -> [[Head|Head]|doubleAll(Tail)].

// 命令行
c(y).
y:doubleAll([1, 2, 3]).
// 输出
[[1|1],[2|2],[3|3]] // 错误结果
```

两端代码区别就在 `[Head|[Head|doubleAll(Tail)]]`和`[[Head|Head]|doubleAll(Tail)]`中用于连接的 `[]` 是放在前面还是放在后面。

在命令行试验几个例子:
```
[1 | [2, 3]] -> [1, 2, 3].
[[1, 2] | 3] -> [[1, 2] | 3].
[[] | [2, 3]] -> [[], 2, 3].
[1. | []] -> [1].
```
书上的解释是： | 右边必须是个列表。左边的参数作为右边参数的第一个元素加到列表的前面(看来是不进行运算原封不动的加进去)。

`|`操作符简直是个神器，有了他可以省去很多复杂的写法。像map函数的定义一句话就能解决。

#### 2. 列表解析
夭寿啦，这个列表解析和python的构造列表(list comprehension)简直一样。

Prolog的模式匹配就是个毒瘤，现在脑子里全是模式匹配，看啥都是模式匹配的运算。。。不能

## 6.4 红药丸
红药丸这段论述我还是赞成的：很多人认为难的方法就是不好，傻瓜方法虽然傻但是稳定可靠，还拿什么”只要满足需求又稳定就够了，没必要冒险“的理由来搪塞。明明就是自己不行，大胆承认不就行了。

### 6.5
看到这里，感觉Erlang还是很好的，确实存在语法上的莫名其妙的规则，可以说是缺陷。但是他的轻量级线程和“就让他崩溃”让人耳目一新。关于线程的监控和重启的实现也是独树一帜。

就像这章最后说的：是非成败，谁又能预料呢。

虽说现在并发编程越来越受到重视，但是还有其他的语言在竞争，并且比Erlang拥有更多的优势，其中之一就是Google爸爸的Golang。开发者口中说着Golang定位不明确，明明声称是是一个系统语言却在web领域广受欢迎，这完全没有阻挡Golang每年的增长率。当然，大多数人认为Golang的未来在云计算。其次还有有Java帝国支撑的Scala、后起之秀Swift(Swift正在努力实现高并发)、帝国强者Java等。随着 协程 的兴起，Python和NodeJs也可以在并发领域挣得一席之地，况且NodeJs定位就是非阻塞io。
